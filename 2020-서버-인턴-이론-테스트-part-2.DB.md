2020년 3월 11일 자택에서 시행된 DB 문제 복기

## 필기   

1. index   

    * 인덱스란? 
        > 원하는 데이터를 빠르게 찾을 수 있는 기능   
        > 별도로 키 값과 바이트 위치로 구성된 인덱스 파일을 생성하여 정보를 제공   
  

2. mysqldump   
    mysqldump [DB 접속 정보] [dump 옵션] [dump 대상 옵션] > 생성 파일

    --host, --user, --password, --port 명령어를 통한 DB 접속 정보 명시 

    [dump 옵션]
    ```
    --single-transaction : dump를 하나의 트랜잭션을 이용해서 실행, 
    InnoDB 스토리지 엔진에서는 Lock없이 일관된 덤프를 받을 수 있다.   

    --master-data : CAHNGE MASTER TO 구문을 포함 bin log 파일명, 위치 정보 및 호스트 정보를 포함   

    --no-data : 데이터는 덤피하지 않고 테이블의 구조만 덤프   
    추가적으로 어떤 옵션이 있는지 인지하기
    ```

    [dump 대상 옵션]
    --all-databases : 모든 DB를 덤프
    
    --databases 명시된 DB를 덤프한다
    
    옵션에 따라 USE <데이터베이스명>; 명령이 덤프 내용에 포함이 되냐 안되냐가 차이가 발생하니 확인.   

* EXPLAIN   
    join 타입.   

    ```
    ALL : 전체 테이블 스캔을 실행   
    index : 인덱스 트리만을 스캔한다   
    ... <- 해당 요소들 확인
    const : 하나의 열만이 존재해 상수로 인식할 수 있다.   
    ```
    추가적으로 EXPLAIN에 대해서 확실히 다시 인지   

* RAID   
    하드디스크를 병렬로 배열해 사용하는 기법   
    저장장치 여러 개를 묶어 한 개와 같은 효과를 얻기 위해 개발된 기법   

    RAID 0 : 두 개 이상의 하드디스크를 병렬로 연결하여 하나의 하드디스크처럼 이용한다.   

    RAID 1 : 두 개 이상의 하드디스크를 병렬로 연결하여 똑같은 복사본을 생성하는 기술   

    RAID 0 와 RAID 1 : 모두 병렬로 연결    
    RAID 0는 복제가 아닌 분할 저장으로 처리 지연이 일어나는 동안 다른 디스크에 저장해서 속도를 향상시키는 목적이며
    RAID 1은 속도 향상에 도움은 되지않고 물리적인 에러 발생에 대비할 수 있는 기법이다.   

* replication 확인   

* CHAR vs VARCHAR   
    두 자료형 모두 문자열을 표현하는 자료형, 길이를 명시해 주어야 한다.
    CHAR형은 고정형 문자열로 2byte값이 들어와도 설정한 길이만큼 공간 할당   
    VARCHAR형은 가변형 문자열로 길이를 넘어서면 짤리지만 2byte값이 들어오면 2byte만 공안을 할당 한다.   

    CAHR형은 길이가 고정되어 있어 추가 연산이 필요없어 검색속도와 읽히는 속도가 빠르다. 사이즈가 고정되어 있으면 char타입을 사용   

    VARCHAR형은 같은 형식에서 데이터의 크기가 차이가 많이나면 사용   

* 수평 파티셔닝, 샤딩 확인

## 실기

   3. com.sundaytoz.mobile.anipang2.google.service.ruby1 라는 item_id를 가진 상품을 총 10번 이상 구매한 유저 수를 구하시오

       ```
       SELECT item_id, user_id, count(item_id)cnt FROM payments WHERE 
       item_id="com.sundaytoz.mobile.anipang2.google.service.ruby1" group by user_id HAVING cnt >= 10; 오답 
       ```

   10.	2018-12-13일 13시부터 14시까지 접속한 유저들의 아이디와 시즌1과 시즌2 중 더 높은 스테이지를 같이 출력하시오    

       ```
       mysql> 
       SELECT a.id, a.modified, 
          if(max(b.stage_id) > max(c.stage_id), max(b.stage_id), 
       max(c.stage_id))max_stage 
       FROM users as a, stage_info as b, stage_info_2 as c 
       WHERE a.id = b.user_id 
         AND a.id = c.user_id 
         AND a.modified >= "2018-12-13 13:00:00" 
         AND a.modified <= "2018-12-13 14:00:00" 
         GROUP BY a.id;
       ```

   11. 2018-11-01부터 매달 총 10000원 이하 결제자 중 시즌 2 스테이지 100 이상 클리어한 유저들은 몇 명인가?   

        ```
        1. 2018-11-01 매달 총 10000원 이상 결제자

        SELECT distinct user_id , sum(price)
        FROM payments 
        WHERE DATE(created) >= DATE('2018-11-01') 
        GROUP BY user_id, MONTH(created), YEAR(created) HAVING sum(price) > 10000 LIMIT 5;
        
        2. 시즌 2 스테이지 100이상 클리어한 유저
        
        SELECT distinct(user_id) FROM stage_info_2 WHERE stage_id >= 100 LIMIT 5;
        
        
        3. 2번 user중에  1번 user가 아닌 인원들을 추리면?
        
        mysql> SELECT count(distinct(A.user_id)) FROM stage_info_2 as A
            -> left join (SELECT distinct user_id
            -> FROM payments
            -> WHERE DATE(created) >= DATE('2018-11-01')
            -> GROUP BY user_id, MONTH(created), YEAR(created) HAVING sum(price) > 10000) as B ON A.user_id = B.user_id
            -> WHERE A.stage_id >= 100 AND B.user_id is null;
        +----------------------------+
        | count(distinct(A.user_id)) |
        +----------------------------+
        |                     282171 |
        +----------------------------+
        1 row in set (1.45 sec)
        ```

   12. 2018년 11월 중에 첫 결제가 일어난 유저 수를 구하시오    

       ```
       mysql> 
       SELECT count(distinct(total.user_id))total_user 
       from 
       ( SELECT user_id 
         FROM payments 
         WHERE YEAR(created) < 2019 
         GROUP BY user_id 
         HAVING min(created) BETWEEN  “2018-11-01” AND “2018-12-01”
       ) as total;
       
       
       +------------+
       | total_user |
       +------------+
       |        455 |
       +------------+
       1 row in set (13.53 sec)
       ```